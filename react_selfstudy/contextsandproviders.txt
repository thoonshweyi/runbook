Step 0: Forget â€œContextâ€ and â€œProviderâ€ for a moment

First, answer this simple question in your head:

How does a child component get data from a parent in React?

The only way you know right now:

ğŸ‘‰ props

function Parent() {
  return <Child name="Alice" />;
}

function Child({ name }) {
  return <h1>{name}</h1>;
}


âœ” This makes sense
âœ” This is how React normally works

Step 1: The Real Problem (Very Concrete)

Now imagine this:

App
 â””â”€â”€ Layout
     â””â”€â”€ Header
         â””â”€â”€ Profile


You want Profile to know the user name.

Without Context, you must do this:
<App user="Alice">
  <Layout user="Alice">
    <Header user="Alice">
      <Profile user="Alice" />
    </Header>
  </Layout>
</App>


ğŸ˜– You are passing user through components that do not need it.

This problem is called prop drilling.

Step 2: What React Context REALLY Is (Plain English)

Context is a way to put data somewhere, so any child can read it, without passing props.

Thatâ€™s it.
No magic. No extra meaning.

Step 3: Think of Context Like a â€œBoxâ€

Imagine this:

You put a value in a box

Any child component can open the box and read the value

That box is Context.

Step 4: Creating the Box (Context)
const UserContext = React.createContext();


This line means:

â€œReact, please create a box named UserContext.â€

Thatâ€™s ALL it does.

â— At this point:

The box is empty

No data inside yet

Step 5: What Is a Provider? (This Is the Key)
Provider = the thing that puts data into the box

Without Provider â†’ the box is empty
With Provider â†’ the box has data

Step 6: Putting Data Into the Box (Provider)
<UserContext.Provider value="Alice">
  <Profile />
</UserContext.Provider>


Read this in English:

â€œPut the value Alice into UserContext, and let Profile read it.â€

ğŸ“Œ Provider does only one job:
ğŸ‘‰ Put data into Context

Step 7: Reading From the Box (useContext)

Inside Profile:

const user = useContext(UserContext);


Read this as:

â€œGive me the value stored in UserContext.â€

Now user === "Alice".

Step 8: Full Working Example (Very Small)
import { createContext, useContext } from "react";

const UserContext = createContext();

function Profile() {
  const user = useContext(UserContext);
  return <h1>Hello {user}</h1>;
}

function App() {
  return (
    <UserContext.Provider value="Alice">
      <Profile />
    </UserContext.Provider>
  );
}

Whatâ€™s happening:

Context is created â†’ empty box

Provider puts "Alice" in the box

Profile reads from the box

Step 9: Why We Even Need Provider

If you remove the Provider:

function App() {
  return <Profile />;
}


Then:

const user = useContext(UserContext); // âŒ undefined


Because:
ğŸ‘‰ No one put data in the box

Step 10: Why We Donâ€™t Just Use Props

With props:

You must pass data step by step

With context:

Any child can read it directly

This is the only reason Context exists.

Step 11: Real-Life Analogy (Very Simple)
Props

ğŸ“¦ You hand a note from person to person

Context

ğŸ“¢ You announce something in a room
Anyone inside the room can hear it

Provider = the person making the announcement
Context = the room
useContext = listening

Step 12: ONE RULE (Very Important)

A component can read Context ONLY if it is inside the Provider.

Outside = no data
Inside = data available

Step 13: When You Should Use Context

Use Context ONLY when:

Many components need the same data

That data doesnâ€™t change every second

Examples:

Logged-in user

Theme (dark/light)


-----------------------------------------------------------------------------------------------------------------------------------
=>Context Performance
Step 1ï¸âƒ£ Create a Context (empty box)
const NumberContext = React.createContext();


This just creates the box.
Nothing inside yet.

Step 2ï¸âƒ£ Create a Provider with INITIAL value
function NumberProvider({ children }) {
  const [number, setNumber] = React.useState(1);

  return (
    <NumberContext.Provider value={number}>
      {children}
    </NumberContext.Provider>
  );
}

What is happening RIGHT NOW?

number starts as 1

Provider gives value = 1

This is the initial provider value

âœ… You are correct: nothing changes yet

Step 3ï¸âƒ£ Child reads the value
function Child() {
  const number = React.useContext(NumberContext);
  console.log("Child render, number =", number);

  return <h1>{number}</h1>;
}

Step 4ï¸âƒ£ App setup
function App() {
  return (
    <NumberProvider>
      <Child />
    </NumberProvider>
  );
}

ğŸ•’ TIME = 0 (Initial render)

What happens:

Provider renders

number = 1

Provider gives value = 1

Child reads 1

Child renders

Console:

Child render, number = 1


Everything is calm.

NOW â€” how does it change later?

ğŸ‘‰ Only one way:
state update inside the Provider

Letâ€™s add that.

Step 5ï¸âƒ£ Add a button INSIDE the Provider
function NumberProvider({ children }) {
  const [number, setNumber] = React.useState(1);

  return (
    <NumberContext.Provider value={number}>
      <button onClick={() => setNumber(2)}>
        Change Number
      </button>
      {children}
    </NumberContext.Provider>
  );
}

ğŸ•’ TIME = 1 (User clicks the button)

User clicks Change Number

This happens:

setNumber(2) is called

State changes: 1 â†’ 2

Provider re-renders

Step 6ï¸âƒ£ Provider renders AGAIN

Now inside Provider:

number = 2


So Provider gives:

value = 2


âš ï¸ This is the key moment:

The Provider value has changed

Step 7ï¸âƒ£ What React does next

React says:

â€œThe Context value changed from 1 to 2â€

So React:

Finds all components using NumberContext

Re-renders them

Step 8ï¸âƒ£ Child re-renders

Child runs again:

const number = useContext(NumberContext);


Now:

number = 2


Console:

Child render, number = 2


UI updates.

ğŸ”‘ VERY IMPORTANT SUMMARY (please read)
Initial Provider

Value does NOT change

Because state did not change

Later Provider change

Some event happens (click, API, timer)

setState is called inside Provider

Provider re-renders

Provider gives NEW value

Children re-render

One sentence that answers your question EXACTLY

A Provider changes later only when its internal state changes, causing it to re-render with a new value.

Final check (please answer)

Do you now understand this timeline?

Initial render â†’ no change
â†“
User / API / event
â†“
setState inside Provider
â†“
Provider re-render
â†“
Provider value changes
â†“
Children re-render


Reply with YES or NO.
If NO, Iâ€™ll show the same thing using a timer instead of a button (even clearer).
Language

App settings
